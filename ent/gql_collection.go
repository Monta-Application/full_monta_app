// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/emoss08/trenova/ent/accountingcontrol"
	"github.com/emoss08/trenova/ent/billingcontrol"
	"github.com/emoss08/trenova/ent/businessunit"
	"github.com/emoss08/trenova/ent/commodity"
	"github.com/emoss08/trenova/ent/dispatchcontrol"
	"github.com/emoss08/trenova/ent/feasibilitytoolcontrol"
	"github.com/emoss08/trenova/ent/generalledgeraccount"
	"github.com/emoss08/trenova/ent/hazardousmaterial"
	"github.com/emoss08/trenova/ent/invoicecontrol"
	"github.com/emoss08/trenova/ent/organization"
	"github.com/emoss08/trenova/ent/routecontrol"
	"github.com/emoss08/trenova/ent/shipmentcontrol"
	"github.com/emoss08/trenova/ent/tablechangealert"
	"github.com/emoss08/trenova/ent/tag"
	"github.com/emoss08/trenova/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ac *AccountingControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*AccountingControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ac, nil
	}
	if err := ac.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ac, nil
}

func (ac *AccountingControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(accountingcontrol.Columns))
		selectedFields = []string{accountingcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ac.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: ac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ac.withBusinessUnit = query
		case "defaultRevAccount":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GeneralLedgerAccountClient{config: ac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ac.withDefaultRevAccount = query
			if _, ok := fieldSeen[accountingcontrol.FieldDefaultRevAccountID]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldDefaultRevAccountID)
				fieldSeen[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
			}
		case "defaultExpAccount":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GeneralLedgerAccountClient{config: ac.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ac.withDefaultExpAccount = query
			if _, ok := fieldSeen[accountingcontrol.FieldDefaultExpAccountID]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldDefaultExpAccountID)
				fieldSeen[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[accountingcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldCreatedAt)
				fieldSeen[accountingcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[accountingcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldUpdatedAt)
				fieldSeen[accountingcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "recThreshold":
			if _, ok := fieldSeen[accountingcontrol.FieldRecThreshold]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldRecThreshold)
				fieldSeen[accountingcontrol.FieldRecThreshold] = struct{}{}
			}
		case "recThresholdAction":
			if _, ok := fieldSeen[accountingcontrol.FieldRecThresholdAction]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldRecThresholdAction)
				fieldSeen[accountingcontrol.FieldRecThresholdAction] = struct{}{}
			}
		case "autoCreateJournalEntries":
			if _, ok := fieldSeen[accountingcontrol.FieldAutoCreateJournalEntries]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldAutoCreateJournalEntries)
				fieldSeen[accountingcontrol.FieldAutoCreateJournalEntries] = struct{}{}
			}
		case "restrictManualJournalEntries":
			if _, ok := fieldSeen[accountingcontrol.FieldRestrictManualJournalEntries]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldRestrictManualJournalEntries)
				fieldSeen[accountingcontrol.FieldRestrictManualJournalEntries] = struct{}{}
			}
		case "requireJournalEntryApproval":
			if _, ok := fieldSeen[accountingcontrol.FieldRequireJournalEntryApproval]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldRequireJournalEntryApproval)
				fieldSeen[accountingcontrol.FieldRequireJournalEntryApproval] = struct{}{}
			}
		case "enableRecNotifications":
			if _, ok := fieldSeen[accountingcontrol.FieldEnableRecNotifications]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldEnableRecNotifications)
				fieldSeen[accountingcontrol.FieldEnableRecNotifications] = struct{}{}
			}
		case "haltOnPendingRec":
			if _, ok := fieldSeen[accountingcontrol.FieldHaltOnPendingRec]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldHaltOnPendingRec)
				fieldSeen[accountingcontrol.FieldHaltOnPendingRec] = struct{}{}
			}
		case "criticalProcesses":
			if _, ok := fieldSeen[accountingcontrol.FieldCriticalProcesses]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldCriticalProcesses)
				fieldSeen[accountingcontrol.FieldCriticalProcesses] = struct{}{}
			}
		case "defaultRevAccountID":
			if _, ok := fieldSeen[accountingcontrol.FieldDefaultRevAccountID]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldDefaultRevAccountID)
				fieldSeen[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
			}
		case "defaultExpAccountID":
			if _, ok := fieldSeen[accountingcontrol.FieldDefaultExpAccountID]; !ok {
				selectedFields = append(selectedFields, accountingcontrol.FieldDefaultExpAccountID)
				fieldSeen[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ac.Select(selectedFields...)
	}
	return nil
}

type accountingcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AccountingControlPaginateOption
}

func newAccountingControlPaginateArgs(rv map[string]any) *accountingcontrolPaginateArgs {
	args := &accountingcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bc *BillingControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*BillingControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bc, nil
	}
	if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bc, nil
}

func (bc *BillingControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(billingcontrol.Columns))
		selectedFields = []string{billingcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[billingcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldCreatedAt)
				fieldSeen[billingcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[billingcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldUpdatedAt)
				fieldSeen[billingcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "removeBillingHistory":
			if _, ok := fieldSeen[billingcontrol.FieldRemoveBillingHistory]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldRemoveBillingHistory)
				fieldSeen[billingcontrol.FieldRemoveBillingHistory] = struct{}{}
			}
		case "autoBillShipment":
			if _, ok := fieldSeen[billingcontrol.FieldAutoBillShipment]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldAutoBillShipment)
				fieldSeen[billingcontrol.FieldAutoBillShipment] = struct{}{}
			}
		case "autoMarkReadyToBill":
			if _, ok := fieldSeen[billingcontrol.FieldAutoMarkReadyToBill]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldAutoMarkReadyToBill)
				fieldSeen[billingcontrol.FieldAutoMarkReadyToBill] = struct{}{}
			}
		case "validateCustomerRates":
			if _, ok := fieldSeen[billingcontrol.FieldValidateCustomerRates]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldValidateCustomerRates)
				fieldSeen[billingcontrol.FieldValidateCustomerRates] = struct{}{}
			}
		case "autoBillCriteria":
			if _, ok := fieldSeen[billingcontrol.FieldAutoBillCriteria]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldAutoBillCriteria)
				fieldSeen[billingcontrol.FieldAutoBillCriteria] = struct{}{}
			}
		case "shipmentTransferCriteria":
			if _, ok := fieldSeen[billingcontrol.FieldShipmentTransferCriteria]; !ok {
				selectedFields = append(selectedFields, billingcontrol.FieldShipmentTransferCriteria)
				fieldSeen[billingcontrol.FieldShipmentTransferCriteria] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bc.Select(selectedFields...)
	}
	return nil
}

type billingcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BillingControlPaginateOption
}

func newBillingControlPaginateArgs(rv map[string]any) *billingcontrolPaginateArgs {
	args := &billingcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bu *BusinessUnitQuery) CollectFields(ctx context.Context, satisfies ...string) (*BusinessUnitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bu, nil
	}
	if err := bu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bu, nil
}

func (bu *BusinessUnitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(businessunit.Columns))
		selectedFields = []string{businessunit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "prev":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: bu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bu.withPrev = query
			if _, ok := fieldSeen[businessunit.FieldParentID]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldParentID)
				fieldSeen[businessunit.FieldParentID] = struct{}{}
			}
		case "next":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: bu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bu.withNext = query
		case "organizations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: bu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bu.WithNamedOrganizations(alias, func(wq *OrganizationQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[businessunit.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldCreatedAt)
				fieldSeen[businessunit.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[businessunit.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldUpdatedAt)
				fieldSeen[businessunit.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[businessunit.FieldStatus]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldStatus)
				fieldSeen[businessunit.FieldStatus] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[businessunit.FieldName]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldName)
				fieldSeen[businessunit.FieldName] = struct{}{}
			}
		case "entityKey":
			if _, ok := fieldSeen[businessunit.FieldEntityKey]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldEntityKey)
				fieldSeen[businessunit.FieldEntityKey] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[businessunit.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldPhoneNumber)
				fieldSeen[businessunit.FieldPhoneNumber] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[businessunit.FieldAddress]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldAddress)
				fieldSeen[businessunit.FieldAddress] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[businessunit.FieldCity]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldCity)
				fieldSeen[businessunit.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[businessunit.FieldState]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldState)
				fieldSeen[businessunit.FieldState] = struct{}{}
			}
		case "country":
			if _, ok := fieldSeen[businessunit.FieldCountry]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldCountry)
				fieldSeen[businessunit.FieldCountry] = struct{}{}
			}
		case "postalCode":
			if _, ok := fieldSeen[businessunit.FieldPostalCode]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldPostalCode)
				fieldSeen[businessunit.FieldPostalCode] = struct{}{}
			}
		case "taxID":
			if _, ok := fieldSeen[businessunit.FieldTaxID]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldTaxID)
				fieldSeen[businessunit.FieldTaxID] = struct{}{}
			}
		case "subscriptionPlan":
			if _, ok := fieldSeen[businessunit.FieldSubscriptionPlan]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldSubscriptionPlan)
				fieldSeen[businessunit.FieldSubscriptionPlan] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[businessunit.FieldDescription]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldDescription)
				fieldSeen[businessunit.FieldDescription] = struct{}{}
			}
		case "legalName":
			if _, ok := fieldSeen[businessunit.FieldLegalName]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldLegalName)
				fieldSeen[businessunit.FieldLegalName] = struct{}{}
			}
		case "contactName":
			if _, ok := fieldSeen[businessunit.FieldContactName]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldContactName)
				fieldSeen[businessunit.FieldContactName] = struct{}{}
			}
		case "contactEmail":
			if _, ok := fieldSeen[businessunit.FieldContactEmail]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldContactEmail)
				fieldSeen[businessunit.FieldContactEmail] = struct{}{}
			}
		case "paidUntil":
			if _, ok := fieldSeen[businessunit.FieldPaidUntil]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldPaidUntil)
				fieldSeen[businessunit.FieldPaidUntil] = struct{}{}
			}
		case "settings":
			if _, ok := fieldSeen[businessunit.FieldSettings]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldSettings)
				fieldSeen[businessunit.FieldSettings] = struct{}{}
			}
		case "freeTrial":
			if _, ok := fieldSeen[businessunit.FieldFreeTrial]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldFreeTrial)
				fieldSeen[businessunit.FieldFreeTrial] = struct{}{}
			}
		case "parentID":
			if _, ok := fieldSeen[businessunit.FieldParentID]; !ok {
				selectedFields = append(selectedFields, businessunit.FieldParentID)
				fieldSeen[businessunit.FieldParentID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bu.Select(selectedFields...)
	}
	return nil
}

type businessunitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BusinessUnitPaginateOption
}

func newBusinessUnitPaginateArgs(rv map[string]any) *businessunitPaginateArgs {
	args := &businessunitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CommodityQuery) CollectFields(ctx context.Context, satisfies ...string) (*CommodityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CommodityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(commodity.Columns))
		selectedFields = []string{commodity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withBusinessUnit = query
			if _, ok := fieldSeen[commodity.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, commodity.FieldBusinessUnitID)
				fieldSeen[commodity.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withOrganization = query
			if _, ok := fieldSeen[commodity.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, commodity.FieldOrganizationID)
				fieldSeen[commodity.FieldOrganizationID] = struct{}{}
			}
		case "hazardousMaterial":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HazardousMaterialClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withHazardousMaterial = query
		case "businessUnitID":
			if _, ok := fieldSeen[commodity.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, commodity.FieldBusinessUnitID)
				fieldSeen[commodity.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[commodity.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, commodity.FieldOrganizationID)
				fieldSeen[commodity.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[commodity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, commodity.FieldCreatedAt)
				fieldSeen[commodity.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[commodity.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, commodity.FieldUpdatedAt)
				fieldSeen[commodity.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[commodity.FieldStatus]; !ok {
				selectedFields = append(selectedFields, commodity.FieldStatus)
				fieldSeen[commodity.FieldStatus] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[commodity.FieldName]; !ok {
				selectedFields = append(selectedFields, commodity.FieldName)
				fieldSeen[commodity.FieldName] = struct{}{}
			}
		case "isHazmat":
			if _, ok := fieldSeen[commodity.FieldIsHazmat]; !ok {
				selectedFields = append(selectedFields, commodity.FieldIsHazmat)
				fieldSeen[commodity.FieldIsHazmat] = struct{}{}
			}
		case "unitOfMeasure":
			if _, ok := fieldSeen[commodity.FieldUnitOfMeasure]; !ok {
				selectedFields = append(selectedFields, commodity.FieldUnitOfMeasure)
				fieldSeen[commodity.FieldUnitOfMeasure] = struct{}{}
			}
		case "minTemp":
			if _, ok := fieldSeen[commodity.FieldMinTemp]; !ok {
				selectedFields = append(selectedFields, commodity.FieldMinTemp)
				fieldSeen[commodity.FieldMinTemp] = struct{}{}
			}
		case "maxTemp":
			if _, ok := fieldSeen[commodity.FieldMaxTemp]; !ok {
				selectedFields = append(selectedFields, commodity.FieldMaxTemp)
				fieldSeen[commodity.FieldMaxTemp] = struct{}{}
			}
		case "setPointTemp":
			if _, ok := fieldSeen[commodity.FieldSetPointTemp]; !ok {
				selectedFields = append(selectedFields, commodity.FieldSetPointTemp)
				fieldSeen[commodity.FieldSetPointTemp] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[commodity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, commodity.FieldDescription)
				fieldSeen[commodity.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type commodityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CommodityPaginateOption
}

func newCommodityPaginateArgs(rv map[string]any) *commodityPaginateArgs {
	args := &commodityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dc *DispatchControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*DispatchControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dc, nil
	}
	if err := dc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dc, nil
}

func (dc *DispatchControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dispatchcontrol.Columns))
		selectedFields = []string{dispatchcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: dc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			dc.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: dc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			dc.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[dispatchcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldCreatedAt)
				fieldSeen[dispatchcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[dispatchcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldUpdatedAt)
				fieldSeen[dispatchcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "recordServiceIncident":
			if _, ok := fieldSeen[dispatchcontrol.FieldRecordServiceIncident]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldRecordServiceIncident)
				fieldSeen[dispatchcontrol.FieldRecordServiceIncident] = struct{}{}
			}
		case "deadheadTarget":
			if _, ok := fieldSeen[dispatchcontrol.FieldDeadheadTarget]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldDeadheadTarget)
				fieldSeen[dispatchcontrol.FieldDeadheadTarget] = struct{}{}
			}
		case "maxShipmentWeightLimit":
			if _, ok := fieldSeen[dispatchcontrol.FieldMaxShipmentWeightLimit]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldMaxShipmentWeightLimit)
				fieldSeen[dispatchcontrol.FieldMaxShipmentWeightLimit] = struct{}{}
			}
		case "gracePeriod":
			if _, ok := fieldSeen[dispatchcontrol.FieldGracePeriod]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldGracePeriod)
				fieldSeen[dispatchcontrol.FieldGracePeriod] = struct{}{}
			}
		case "enforceWorkerAssign":
			if _, ok := fieldSeen[dispatchcontrol.FieldEnforceWorkerAssign]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldEnforceWorkerAssign)
				fieldSeen[dispatchcontrol.FieldEnforceWorkerAssign] = struct{}{}
			}
		case "trailerContinuity":
			if _, ok := fieldSeen[dispatchcontrol.FieldTrailerContinuity]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldTrailerContinuity)
				fieldSeen[dispatchcontrol.FieldTrailerContinuity] = struct{}{}
			}
		case "dupeTrailerCheck":
			if _, ok := fieldSeen[dispatchcontrol.FieldDupeTrailerCheck]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldDupeTrailerCheck)
				fieldSeen[dispatchcontrol.FieldDupeTrailerCheck] = struct{}{}
			}
		case "maintenanceCompliance":
			if _, ok := fieldSeen[dispatchcontrol.FieldMaintenanceCompliance]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldMaintenanceCompliance)
				fieldSeen[dispatchcontrol.FieldMaintenanceCompliance] = struct{}{}
			}
		case "regulatoryCheck":
			if _, ok := fieldSeen[dispatchcontrol.FieldRegulatoryCheck]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldRegulatoryCheck)
				fieldSeen[dispatchcontrol.FieldRegulatoryCheck] = struct{}{}
			}
		case "prevShipmentOnHold":
			if _, ok := fieldSeen[dispatchcontrol.FieldPrevShipmentOnHold]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldPrevShipmentOnHold)
				fieldSeen[dispatchcontrol.FieldPrevShipmentOnHold] = struct{}{}
			}
		case "workerTimeAwayRestriction":
			if _, ok := fieldSeen[dispatchcontrol.FieldWorkerTimeAwayRestriction]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldWorkerTimeAwayRestriction)
				fieldSeen[dispatchcontrol.FieldWorkerTimeAwayRestriction] = struct{}{}
			}
		case "tractorWorkerFleetConstraint":
			if _, ok := fieldSeen[dispatchcontrol.FieldTractorWorkerFleetConstraint]; !ok {
				selectedFields = append(selectedFields, dispatchcontrol.FieldTractorWorkerFleetConstraint)
				fieldSeen[dispatchcontrol.FieldTractorWorkerFleetConstraint] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dc.Select(selectedFields...)
	}
	return nil
}

type dispatchcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DispatchControlPaginateOption
}

func newDispatchControlPaginateArgs(rv map[string]any) *dispatchcontrolPaginateArgs {
	args := &dispatchcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ftc *FeasibilityToolControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*FeasibilityToolControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ftc, nil
	}
	if err := ftc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ftc, nil
}

func (ftc *FeasibilityToolControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(feasibilitytoolcontrol.Columns))
		selectedFields = []string{feasibilitytoolcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ftc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ftc.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: ftc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ftc.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldCreatedAt)
				fieldSeen[feasibilitytoolcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldUpdatedAt)
				fieldSeen[feasibilitytoolcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "otpOperator":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldOtpOperator]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldOtpOperator)
				fieldSeen[feasibilitytoolcontrol.FieldOtpOperator] = struct{}{}
			}
		case "otpValue":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldOtpValue]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldOtpValue)
				fieldSeen[feasibilitytoolcontrol.FieldOtpValue] = struct{}{}
			}
		case "mpwOperator":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpwOperator]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpwOperator)
				fieldSeen[feasibilitytoolcontrol.FieldMpwOperator] = struct{}{}
			}
		case "mpwValue":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpwValue]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpwValue)
				fieldSeen[feasibilitytoolcontrol.FieldMpwValue] = struct{}{}
			}
		case "mpdOperator":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpdOperator]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpdOperator)
				fieldSeen[feasibilitytoolcontrol.FieldMpdOperator] = struct{}{}
			}
		case "mpdValue":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpdValue]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpdValue)
				fieldSeen[feasibilitytoolcontrol.FieldMpdValue] = struct{}{}
			}
		case "mpgOperator":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpgOperator]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpgOperator)
				fieldSeen[feasibilitytoolcontrol.FieldMpgOperator] = struct{}{}
			}
		case "mpgValue":
			if _, ok := fieldSeen[feasibilitytoolcontrol.FieldMpgValue]; !ok {
				selectedFields = append(selectedFields, feasibilitytoolcontrol.FieldMpgValue)
				fieldSeen[feasibilitytoolcontrol.FieldMpgValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ftc.Select(selectedFields...)
	}
	return nil
}

type feasibilitytoolcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FeasibilityToolControlPaginateOption
}

func newFeasibilityToolControlPaginateArgs(rv map[string]any) *feasibilitytoolcontrolPaginateArgs {
	args := &feasibilitytoolcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gla *GeneralLedgerAccountQuery) CollectFields(ctx context.Context, satisfies ...string) (*GeneralLedgerAccountQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gla, nil
	}
	if err := gla.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gla, nil
}

func (gla *GeneralLedgerAccountQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(generalledgeraccount.Columns))
		selectedFields = []string{generalledgeraccount.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: gla.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gla.withBusinessUnit = query
			if _, ok := fieldSeen[generalledgeraccount.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldBusinessUnitID)
				fieldSeen[generalledgeraccount.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: gla.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gla.withOrganization = query
			if _, ok := fieldSeen[generalledgeraccount.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldOrganizationID)
				fieldSeen[generalledgeraccount.FieldOrganizationID] = struct{}{}
			}
		case "tags":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: gla.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gla.WithNamedTags(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "businessUnitID":
			if _, ok := fieldSeen[generalledgeraccount.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldBusinessUnitID)
				fieldSeen[generalledgeraccount.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[generalledgeraccount.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldOrganizationID)
				fieldSeen[generalledgeraccount.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[generalledgeraccount.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldCreatedAt)
				fieldSeen[generalledgeraccount.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[generalledgeraccount.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldUpdatedAt)
				fieldSeen[generalledgeraccount.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[generalledgeraccount.FieldStatus]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldStatus)
				fieldSeen[generalledgeraccount.FieldStatus] = struct{}{}
			}
		case "accountNumber":
			if _, ok := fieldSeen[generalledgeraccount.FieldAccountNumber]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldAccountNumber)
				fieldSeen[generalledgeraccount.FieldAccountNumber] = struct{}{}
			}
		case "accountType":
			if _, ok := fieldSeen[generalledgeraccount.FieldAccountType]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldAccountType)
				fieldSeen[generalledgeraccount.FieldAccountType] = struct{}{}
			}
		case "cashFlowType":
			if _, ok := fieldSeen[generalledgeraccount.FieldCashFlowType]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldCashFlowType)
				fieldSeen[generalledgeraccount.FieldCashFlowType] = struct{}{}
			}
		case "accountSubType":
			if _, ok := fieldSeen[generalledgeraccount.FieldAccountSubType]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldAccountSubType)
				fieldSeen[generalledgeraccount.FieldAccountSubType] = struct{}{}
			}
		case "accountClass":
			if _, ok := fieldSeen[generalledgeraccount.FieldAccountClass]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldAccountClass)
				fieldSeen[generalledgeraccount.FieldAccountClass] = struct{}{}
			}
		case "balance":
			if _, ok := fieldSeen[generalledgeraccount.FieldBalance]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldBalance)
				fieldSeen[generalledgeraccount.FieldBalance] = struct{}{}
			}
		case "interestRate":
			if _, ok := fieldSeen[generalledgeraccount.FieldInterestRate]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldInterestRate)
				fieldSeen[generalledgeraccount.FieldInterestRate] = struct{}{}
			}
		case "dateOpened":
			if _, ok := fieldSeen[generalledgeraccount.FieldDateOpened]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldDateOpened)
				fieldSeen[generalledgeraccount.FieldDateOpened] = struct{}{}
			}
		case "dateClosed":
			if _, ok := fieldSeen[generalledgeraccount.FieldDateClosed]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldDateClosed)
				fieldSeen[generalledgeraccount.FieldDateClosed] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[generalledgeraccount.FieldNotes]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldNotes)
				fieldSeen[generalledgeraccount.FieldNotes] = struct{}{}
			}
		case "isTaxRelevant":
			if _, ok := fieldSeen[generalledgeraccount.FieldIsTaxRelevant]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldIsTaxRelevant)
				fieldSeen[generalledgeraccount.FieldIsTaxRelevant] = struct{}{}
			}
		case "isReconciled":
			if _, ok := fieldSeen[generalledgeraccount.FieldIsReconciled]; !ok {
				selectedFields = append(selectedFields, generalledgeraccount.FieldIsReconciled)
				fieldSeen[generalledgeraccount.FieldIsReconciled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gla.Select(selectedFields...)
	}
	return nil
}

type generalledgeraccountPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GeneralLedgerAccountPaginateOption
}

func newGeneralLedgerAccountPaginateArgs(rv map[string]any) *generalledgeraccountPaginateArgs {
	args := &generalledgeraccountPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hm *HazardousMaterialQuery) CollectFields(ctx context.Context, satisfies ...string) (*HazardousMaterialQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hm, nil
	}
	if err := hm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hm, nil
}

func (hm *HazardousMaterialQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hazardousmaterial.Columns))
		selectedFields = []string{hazardousmaterial.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: hm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hm.withBusinessUnit = query
			if _, ok := fieldSeen[hazardousmaterial.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldBusinessUnitID)
				fieldSeen[hazardousmaterial.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: hm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hm.withOrganization = query
			if _, ok := fieldSeen[hazardousmaterial.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldOrganizationID)
				fieldSeen[hazardousmaterial.FieldOrganizationID] = struct{}{}
			}
		case "commodities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommodityClient{config: hm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hm.WithNamedCommodities(alias, func(wq *CommodityQuery) {
				*wq = *query
			})
		case "businessUnitID":
			if _, ok := fieldSeen[hazardousmaterial.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldBusinessUnitID)
				fieldSeen[hazardousmaterial.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[hazardousmaterial.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldOrganizationID)
				fieldSeen[hazardousmaterial.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hazardousmaterial.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldCreatedAt)
				fieldSeen[hazardousmaterial.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[hazardousmaterial.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldUpdatedAt)
				fieldSeen[hazardousmaterial.FieldUpdatedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hazardousmaterial.FieldName]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldName)
				fieldSeen[hazardousmaterial.FieldName] = struct{}{}
			}
		case "hazardClass":
			if _, ok := fieldSeen[hazardousmaterial.FieldHazardClass]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldHazardClass)
				fieldSeen[hazardousmaterial.FieldHazardClass] = struct{}{}
			}
		case "ergNumber":
			if _, ok := fieldSeen[hazardousmaterial.FieldErgNumber]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldErgNumber)
				fieldSeen[hazardousmaterial.FieldErgNumber] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[hazardousmaterial.FieldDescription]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldDescription)
				fieldSeen[hazardousmaterial.FieldDescription] = struct{}{}
			}
		case "packingGroup":
			if _, ok := fieldSeen[hazardousmaterial.FieldPackingGroup]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldPackingGroup)
				fieldSeen[hazardousmaterial.FieldPackingGroup] = struct{}{}
			}
		case "properShippingName":
			if _, ok := fieldSeen[hazardousmaterial.FieldProperShippingName]; !ok {
				selectedFields = append(selectedFields, hazardousmaterial.FieldProperShippingName)
				fieldSeen[hazardousmaterial.FieldProperShippingName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hm.Select(selectedFields...)
	}
	return nil
}

type hazardousmaterialPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HazardousMaterialPaginateOption
}

func newHazardousMaterialPaginateArgs(rv map[string]any) *hazardousmaterialPaginateArgs {
	args := &hazardousmaterialPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ic *InvoiceControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*InvoiceControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ic, nil
	}
	if err := ic.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ic, nil
}

func (ic *InvoiceControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(invoicecontrol.Columns))
		selectedFields = []string{invoicecontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: ic.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ic.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: ic.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ic.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[invoicecontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldCreatedAt)
				fieldSeen[invoicecontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[invoicecontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldUpdatedAt)
				fieldSeen[invoicecontrol.FieldUpdatedAt] = struct{}{}
			}
		case "invoiceNumberPrefix":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceNumberPrefix]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceNumberPrefix)
				fieldSeen[invoicecontrol.FieldInvoiceNumberPrefix] = struct{}{}
			}
		case "creditMemoNumberPrefix":
			if _, ok := fieldSeen[invoicecontrol.FieldCreditMemoNumberPrefix]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldCreditMemoNumberPrefix)
				fieldSeen[invoicecontrol.FieldCreditMemoNumberPrefix] = struct{}{}
			}
		case "invoiceTerms":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceTerms]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceTerms)
				fieldSeen[invoicecontrol.FieldInvoiceTerms] = struct{}{}
			}
		case "invoiceFooter":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceFooter]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceFooter)
				fieldSeen[invoicecontrol.FieldInvoiceFooter] = struct{}{}
			}
		case "invoiceLogoURL":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceLogoURL]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceLogoURL)
				fieldSeen[invoicecontrol.FieldInvoiceLogoURL] = struct{}{}
			}
		case "invoiceDateFormat":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceDateFormat]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceDateFormat)
				fieldSeen[invoicecontrol.FieldInvoiceDateFormat] = struct{}{}
			}
		case "invoiceDueAfterDays":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceDueAfterDays]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceDueAfterDays)
				fieldSeen[invoicecontrol.FieldInvoiceDueAfterDays] = struct{}{}
			}
		case "invoiceLogoWidth":
			if _, ok := fieldSeen[invoicecontrol.FieldInvoiceLogoWidth]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldInvoiceLogoWidth)
				fieldSeen[invoicecontrol.FieldInvoiceLogoWidth] = struct{}{}
			}
		case "showAmountDue":
			if _, ok := fieldSeen[invoicecontrol.FieldShowAmountDue]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldShowAmountDue)
				fieldSeen[invoicecontrol.FieldShowAmountDue] = struct{}{}
			}
		case "attachPdf":
			if _, ok := fieldSeen[invoicecontrol.FieldAttachPdf]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldAttachPdf)
				fieldSeen[invoicecontrol.FieldAttachPdf] = struct{}{}
			}
		case "showInvoiceDueDate":
			if _, ok := fieldSeen[invoicecontrol.FieldShowInvoiceDueDate]; !ok {
				selectedFields = append(selectedFields, invoicecontrol.FieldShowInvoiceDueDate)
				fieldSeen[invoicecontrol.FieldShowInvoiceDueDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ic.Select(selectedFields...)
	}
	return nil
}

type invoicecontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InvoiceControlPaginateOption
}

func newInvoiceControlPaginateArgs(rv map[string]any) *invoicecontrolPaginateArgs {
	args := &invoicecontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrganizationQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrganizationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrganizationQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(organization.Columns))
		selectedFields = []string{organization.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withBusinessUnit = query
			if _, ok := fieldSeen[organization.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, organization.FieldBusinessUnitID)
				fieldSeen[organization.FieldBusinessUnitID] = struct{}{}
			}
		case "accountingControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AccountingControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withAccountingControl = query
		case "billingControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BillingControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withBillingControl = query
		case "dispatchControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DispatchControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withDispatchControl = query
		case "feasibilityToolControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FeasibilityToolControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withFeasibilityToolControl = query
		case "invoiceControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InvoiceControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withInvoiceControl = query
		case "routeControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RouteControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withRouteControl = query
		case "shipmentControl":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentControlClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			o.withShipmentControl = query
		case "createdAt":
			if _, ok := fieldSeen[organization.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldCreatedAt)
				fieldSeen[organization.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[organization.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, organization.FieldUpdatedAt)
				fieldSeen[organization.FieldUpdatedAt] = struct{}{}
			}
		case "businessUnitID":
			if _, ok := fieldSeen[organization.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, organization.FieldBusinessUnitID)
				fieldSeen[organization.FieldBusinessUnitID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[organization.FieldName]; !ok {
				selectedFields = append(selectedFields, organization.FieldName)
				fieldSeen[organization.FieldName] = struct{}{}
			}
		case "scacCode":
			if _, ok := fieldSeen[organization.FieldScacCode]; !ok {
				selectedFields = append(selectedFields, organization.FieldScacCode)
				fieldSeen[organization.FieldScacCode] = struct{}{}
			}
		case "dotNumber":
			if _, ok := fieldSeen[organization.FieldDotNumber]; !ok {
				selectedFields = append(selectedFields, organization.FieldDotNumber)
				fieldSeen[organization.FieldDotNumber] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[organization.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, organization.FieldLogoURL)
				fieldSeen[organization.FieldLogoURL] = struct{}{}
			}
		case "orgType":
			if _, ok := fieldSeen[organization.FieldOrgType]; !ok {
				selectedFields = append(selectedFields, organization.FieldOrgType)
				fieldSeen[organization.FieldOrgType] = struct{}{}
			}
		case "timezone":
			if _, ok := fieldSeen[organization.FieldTimezone]; !ok {
				selectedFields = append(selectedFields, organization.FieldTimezone)
				fieldSeen[organization.FieldTimezone] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type organizationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrganizationPaginateOption
}

func newOrganizationPaginateArgs(rv map[string]any) *organizationPaginateArgs {
	args := &organizationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rc *RouteControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*RouteControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rc, nil
	}
	if err := rc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rc, nil
}

func (rc *RouteControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(routecontrol.Columns))
		selectedFields = []string{routecontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			rc.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			rc.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[routecontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, routecontrol.FieldCreatedAt)
				fieldSeen[routecontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[routecontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, routecontrol.FieldUpdatedAt)
				fieldSeen[routecontrol.FieldUpdatedAt] = struct{}{}
			}
		case "distanceMethod":
			if _, ok := fieldSeen[routecontrol.FieldDistanceMethod]; !ok {
				selectedFields = append(selectedFields, routecontrol.FieldDistanceMethod)
				fieldSeen[routecontrol.FieldDistanceMethod] = struct{}{}
			}
		case "mileageUnit":
			if _, ok := fieldSeen[routecontrol.FieldMileageUnit]; !ok {
				selectedFields = append(selectedFields, routecontrol.FieldMileageUnit)
				fieldSeen[routecontrol.FieldMileageUnit] = struct{}{}
			}
		case "generateRoutes":
			if _, ok := fieldSeen[routecontrol.FieldGenerateRoutes]; !ok {
				selectedFields = append(selectedFields, routecontrol.FieldGenerateRoutes)
				fieldSeen[routecontrol.FieldGenerateRoutes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rc.Select(selectedFields...)
	}
	return nil
}

type routecontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RouteControlPaginateOption
}

func newRouteControlPaginateArgs(rv map[string]any) *routecontrolPaginateArgs {
	args := &routecontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sc *ShipmentControlQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentControlQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sc, nil
	}
	if err := sc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sc, nil
}

func (sc *ShipmentControlQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentcontrol.Columns))
		selectedFields = []string{shipmentcontrol.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: sc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sc.withOrganization = query
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: sc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sc.withBusinessUnit = query
		case "createdAt":
			if _, ok := fieldSeen[shipmentcontrol.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldCreatedAt)
				fieldSeen[shipmentcontrol.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[shipmentcontrol.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldUpdatedAt)
				fieldSeen[shipmentcontrol.FieldUpdatedAt] = struct{}{}
			}
		case "autoRateShipment":
			if _, ok := fieldSeen[shipmentcontrol.FieldAutoRateShipment]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldAutoRateShipment)
				fieldSeen[shipmentcontrol.FieldAutoRateShipment] = struct{}{}
			}
		case "calculateDistance":
			if _, ok := fieldSeen[shipmentcontrol.FieldCalculateDistance]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldCalculateDistance)
				fieldSeen[shipmentcontrol.FieldCalculateDistance] = struct{}{}
			}
		case "enforceRevCode":
			if _, ok := fieldSeen[shipmentcontrol.FieldEnforceRevCode]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldEnforceRevCode)
				fieldSeen[shipmentcontrol.FieldEnforceRevCode] = struct{}{}
			}
		case "enforceVoidedComm":
			if _, ok := fieldSeen[shipmentcontrol.FieldEnforceVoidedComm]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldEnforceVoidedComm)
				fieldSeen[shipmentcontrol.FieldEnforceVoidedComm] = struct{}{}
			}
		case "generateRoutes":
			if _, ok := fieldSeen[shipmentcontrol.FieldGenerateRoutes]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldGenerateRoutes)
				fieldSeen[shipmentcontrol.FieldGenerateRoutes] = struct{}{}
			}
		case "enforceCommodity":
			if _, ok := fieldSeen[shipmentcontrol.FieldEnforceCommodity]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldEnforceCommodity)
				fieldSeen[shipmentcontrol.FieldEnforceCommodity] = struct{}{}
			}
		case "autoSequenceStops":
			if _, ok := fieldSeen[shipmentcontrol.FieldAutoSequenceStops]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldAutoSequenceStops)
				fieldSeen[shipmentcontrol.FieldAutoSequenceStops] = struct{}{}
			}
		case "autoShipmentTotal":
			if _, ok := fieldSeen[shipmentcontrol.FieldAutoShipmentTotal]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldAutoShipmentTotal)
				fieldSeen[shipmentcontrol.FieldAutoShipmentTotal] = struct{}{}
			}
		case "enforceOriginDestination":
			if _, ok := fieldSeen[shipmentcontrol.FieldEnforceOriginDestination]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldEnforceOriginDestination)
				fieldSeen[shipmentcontrol.FieldEnforceOriginDestination] = struct{}{}
			}
		case "checkForDuplicateBol":
			if _, ok := fieldSeen[shipmentcontrol.FieldCheckForDuplicateBol]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldCheckForDuplicateBol)
				fieldSeen[shipmentcontrol.FieldCheckForDuplicateBol] = struct{}{}
			}
		case "sendPlacardInfo":
			if _, ok := fieldSeen[shipmentcontrol.FieldSendPlacardInfo]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldSendPlacardInfo)
				fieldSeen[shipmentcontrol.FieldSendPlacardInfo] = struct{}{}
			}
		case "enforceHazmatSegRules":
			if _, ok := fieldSeen[shipmentcontrol.FieldEnforceHazmatSegRules]; !ok {
				selectedFields = append(selectedFields, shipmentcontrol.FieldEnforceHazmatSegRules)
				fieldSeen[shipmentcontrol.FieldEnforceHazmatSegRules] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sc.Select(selectedFields...)
	}
	return nil
}

type shipmentcontrolPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentControlPaginateOption
}

func newShipmentControlPaginateArgs(rv map[string]any) *shipmentcontrolPaginateArgs {
	args := &shipmentcontrolPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tca *TableChangeAlertQuery) CollectFields(ctx context.Context, satisfies ...string) (*TableChangeAlertQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tca, nil
	}
	if err := tca.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tca, nil
}

func (tca *TableChangeAlertQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tablechangealert.Columns))
		selectedFields = []string{tablechangealert.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: tca.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tca.withBusinessUnit = query
			if _, ok := fieldSeen[tablechangealert.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldBusinessUnitID)
				fieldSeen[tablechangealert.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: tca.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tca.withOrganization = query
			if _, ok := fieldSeen[tablechangealert.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldOrganizationID)
				fieldSeen[tablechangealert.FieldOrganizationID] = struct{}{}
			}
		case "businessUnitID":
			if _, ok := fieldSeen[tablechangealert.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldBusinessUnitID)
				fieldSeen[tablechangealert.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[tablechangealert.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldOrganizationID)
				fieldSeen[tablechangealert.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[tablechangealert.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldCreatedAt)
				fieldSeen[tablechangealert.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tablechangealert.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldUpdatedAt)
				fieldSeen[tablechangealert.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[tablechangealert.FieldStatus]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldStatus)
				fieldSeen[tablechangealert.FieldStatus] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tablechangealert.FieldName]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldName)
				fieldSeen[tablechangealert.FieldName] = struct{}{}
			}
		case "databaseAction":
			if _, ok := fieldSeen[tablechangealert.FieldDatabaseAction]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldDatabaseAction)
				fieldSeen[tablechangealert.FieldDatabaseAction] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[tablechangealert.FieldSource]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldSource)
				fieldSeen[tablechangealert.FieldSource] = struct{}{}
			}
		case "tableName":
			if _, ok := fieldSeen[tablechangealert.FieldTableName]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldTableName)
				fieldSeen[tablechangealert.FieldTableName] = struct{}{}
			}
		case "topic":
			if _, ok := fieldSeen[tablechangealert.FieldTopic]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldTopic)
				fieldSeen[tablechangealert.FieldTopic] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[tablechangealert.FieldDescription]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldDescription)
				fieldSeen[tablechangealert.FieldDescription] = struct{}{}
			}
		case "customSubject":
			if _, ok := fieldSeen[tablechangealert.FieldCustomSubject]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldCustomSubject)
				fieldSeen[tablechangealert.FieldCustomSubject] = struct{}{}
			}
		case "functionName":
			if _, ok := fieldSeen[tablechangealert.FieldFunctionName]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldFunctionName)
				fieldSeen[tablechangealert.FieldFunctionName] = struct{}{}
			}
		case "triggerName":
			if _, ok := fieldSeen[tablechangealert.FieldTriggerName]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldTriggerName)
				fieldSeen[tablechangealert.FieldTriggerName] = struct{}{}
			}
		case "listenerName":
			if _, ok := fieldSeen[tablechangealert.FieldListenerName]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldListenerName)
				fieldSeen[tablechangealert.FieldListenerName] = struct{}{}
			}
		case "emailRecipients":
			if _, ok := fieldSeen[tablechangealert.FieldEmailRecipients]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldEmailRecipients)
				fieldSeen[tablechangealert.FieldEmailRecipients] = struct{}{}
			}
		case "conditionalLogic":
			if _, ok := fieldSeen[tablechangealert.FieldConditionalLogic]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldConditionalLogic)
				fieldSeen[tablechangealert.FieldConditionalLogic] = struct{}{}
			}
		case "effectiveDate":
			if _, ok := fieldSeen[tablechangealert.FieldEffectiveDate]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldEffectiveDate)
				fieldSeen[tablechangealert.FieldEffectiveDate] = struct{}{}
			}
		case "expirationDate":
			if _, ok := fieldSeen[tablechangealert.FieldExpirationDate]; !ok {
				selectedFields = append(selectedFields, tablechangealert.FieldExpirationDate)
				fieldSeen[tablechangealert.FieldExpirationDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tca.Select(selectedFields...)
	}
	return nil
}

type tablechangealertPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TableChangeAlertPaginateOption
}

func newTableChangeAlertPaginateArgs(rv map[string]any) *tablechangealertPaginateArgs {
	args := &tablechangealertPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TagQuery) CollectFields(ctx context.Context, satisfies ...string) (*TagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TagQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tag.Columns))
		selectedFields = []string{tag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withBusinessUnit = query
			if _, ok := fieldSeen[tag.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, tag.FieldBusinessUnitID)
				fieldSeen[tag.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withOrganization = query
			if _, ok := fieldSeen[tag.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, tag.FieldOrganizationID)
				fieldSeen[tag.FieldOrganizationID] = struct{}{}
			}
		case "businessUnitID":
			if _, ok := fieldSeen[tag.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, tag.FieldBusinessUnitID)
				fieldSeen[tag.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[tag.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, tag.FieldOrganizationID)
				fieldSeen[tag.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[tag.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, tag.FieldCreatedAt)
				fieldSeen[tag.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[tag.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, tag.FieldUpdatedAt)
				fieldSeen[tag.FieldUpdatedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tag.FieldName]; !ok {
				selectedFields = append(selectedFields, tag.FieldName)
				fieldSeen[tag.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[tag.FieldDescription]; !ok {
				selectedFields = append(selectedFields, tag.FieldDescription)
				fieldSeen[tag.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TagPaginateOption
}

func newTagPaginateArgs(rv map[string]any) *tagPaginateArgs {
	args := &tagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "businessUnit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessUnitClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.withBusinessUnit = query
			if _, ok := fieldSeen[user.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, user.FieldBusinessUnitID)
				fieldSeen[user.FieldBusinessUnitID] = struct{}{}
			}
		case "organization":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrganizationClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.withOrganization = query
			if _, ok := fieldSeen[user.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, user.FieldOrganizationID)
				fieldSeen[user.FieldOrganizationID] = struct{}{}
			}
		case "businessUnitID":
			if _, ok := fieldSeen[user.FieldBusinessUnitID]; !ok {
				selectedFields = append(selectedFields, user.FieldBusinessUnitID)
				fieldSeen[user.FieldBusinessUnitID] = struct{}{}
			}
		case "organizationID":
			if _, ok := fieldSeen[user.FieldOrganizationID]; !ok {
				selectedFields = append(selectedFields, user.FieldOrganizationID)
				fieldSeen[user.FieldOrganizationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[user.FieldStatus]; !ok {
				selectedFields = append(selectedFields, user.FieldStatus)
				fieldSeen[user.FieldStatus] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "dateJoined":
			if _, ok := fieldSeen[user.FieldDateJoined]; !ok {
				selectedFields = append(selectedFields, user.FieldDateJoined)
				fieldSeen[user.FieldDateJoined] = struct{}{}
			}
		case "timezone":
			if _, ok := fieldSeen[user.FieldTimezone]; !ok {
				selectedFields = append(selectedFields, user.FieldTimezone)
				fieldSeen[user.FieldTimezone] = struct{}{}
			}
		case "profilePicURL":
			if _, ok := fieldSeen[user.FieldProfilePicURL]; !ok {
				selectedFields = append(selectedFields, user.FieldProfilePicURL)
				fieldSeen[user.FieldProfilePicURL] = struct{}{}
			}
		case "thumbnailURL":
			if _, ok := fieldSeen[user.FieldThumbnailURL]; !ok {
				selectedFields = append(selectedFields, user.FieldThumbnailURL)
				fieldSeen[user.FieldThumbnailURL] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[user.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, user.FieldPhoneNumber)
				fieldSeen[user.FieldPhoneNumber] = struct{}{}
			}
		case "isAdmin":
			if _, ok := fieldSeen[user.FieldIsAdmin]; !ok {
				selectedFields = append(selectedFields, user.FieldIsAdmin)
				fieldSeen[user.FieldIsAdmin] = struct{}{}
			}
		case "isSuperAdmin":
			if _, ok := fieldSeen[user.FieldIsSuperAdmin]; !ok {
				selectedFields = append(selectedFields, user.FieldIsSuperAdmin)
				fieldSeen[user.FieldIsSuperAdmin] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
