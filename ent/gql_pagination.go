// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/emoss08/trenova/ent/accountingcontrol"
	"github.com/emoss08/trenova/ent/billingcontrol"
	"github.com/emoss08/trenova/ent/businessunit"
	"github.com/emoss08/trenova/ent/commodity"
	"github.com/emoss08/trenova/ent/dispatchcontrol"
	"github.com/emoss08/trenova/ent/feasibilitytoolcontrol"
	"github.com/emoss08/trenova/ent/generalledgeraccount"
	"github.com/emoss08/trenova/ent/hazardousmaterial"
	"github.com/emoss08/trenova/ent/invoicecontrol"
	"github.com/emoss08/trenova/ent/organization"
	"github.com/emoss08/trenova/ent/routecontrol"
	"github.com/emoss08/trenova/ent/shipmentcontrol"
	"github.com/emoss08/trenova/ent/tablechangealert"
	"github.com/emoss08/trenova/ent/tag"
	"github.com/emoss08/trenova/ent/user"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AccountingControlEdge is the edge representation of AccountingControl.
type AccountingControlEdge struct {
	Node   *AccountingControl `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// AccountingControlConnection is the connection containing edges to AccountingControl.
type AccountingControlConnection struct {
	Edges      []*AccountingControlEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *AccountingControlConnection) build(nodes []*AccountingControl, pager *accountingcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccountingControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccountingControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccountingControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccountingControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccountingControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccountingControlPaginateOption enables pagination customization.
type AccountingControlPaginateOption func(*accountingcontrolPager) error

// WithAccountingControlOrder configures pagination ordering.
func WithAccountingControlOrder(order *AccountingControlOrder) AccountingControlPaginateOption {
	if order == nil {
		order = DefaultAccountingControlOrder
	}
	o := *order
	return func(pager *accountingcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountingControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountingControlFilter configures pagination filter.
func WithAccountingControlFilter(filter func(*AccountingControlQuery) (*AccountingControlQuery, error)) AccountingControlPaginateOption {
	return func(pager *accountingcontrolPager) error {
		if filter == nil {
			return errors.New("AccountingControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountingcontrolPager struct {
	reverse bool
	order   *AccountingControlOrder
	filter  func(*AccountingControlQuery) (*AccountingControlQuery, error)
}

func newAccountingControlPager(opts []AccountingControlPaginateOption, reverse bool) (*accountingcontrolPager, error) {
	pager := &accountingcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountingControlOrder
	}
	return pager, nil
}

func (p *accountingcontrolPager) applyFilter(query *AccountingControlQuery) (*AccountingControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountingcontrolPager) toCursor(ac *AccountingControl) Cursor {
	return p.order.Field.toCursor(ac)
}

func (p *accountingcontrolPager) applyCursors(query *AccountingControlQuery, after, before *Cursor) (*AccountingControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAccountingControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accountingcontrolPager) applyOrder(query *AccountingControlQuery) *AccountingControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAccountingControlOrder.Field {
		query = query.Order(DefaultAccountingControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *accountingcontrolPager) orderExpr(query *AccountingControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccountingControlOrder.Field {
			b.Comma().Ident(DefaultAccountingControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccountingControl.
func (ac *AccountingControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountingControlPaginateOption,
) (*AccountingControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountingControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ac, err = pager.applyFilter(ac); err != nil {
		return nil, err
	}
	conn := &AccountingControlConnection{Edges: []*AccountingControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ac.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ac, err = pager.applyCursors(ac, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ac.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ac.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ac = pager.applyOrder(ac)
	nodes, err := ac.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccountingControlOrderField defines the ordering field of AccountingControl.
type AccountingControlOrderField struct {
	// Value extracts the ordering value from the given AccountingControl.
	Value    func(*AccountingControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accountingcontrol.OrderOption
	toCursor func(*AccountingControl) Cursor
}

// AccountingControlOrder defines the ordering of AccountingControl.
type AccountingControlOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *AccountingControlOrderField `json:"field"`
}

// DefaultAccountingControlOrder is the default ordering of AccountingControl.
var DefaultAccountingControlOrder = &AccountingControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccountingControlOrderField{
		Value: func(ac *AccountingControl) (ent.Value, error) {
			return ac.ID, nil
		},
		column: accountingcontrol.FieldID,
		toTerm: accountingcontrol.ByID,
		toCursor: func(ac *AccountingControl) Cursor {
			return Cursor{ID: ac.ID}
		},
	},
}

// ToEdge converts AccountingControl into AccountingControlEdge.
func (ac *AccountingControl) ToEdge(order *AccountingControlOrder) *AccountingControlEdge {
	if order == nil {
		order = DefaultAccountingControlOrder
	}
	return &AccountingControlEdge{
		Node:   ac,
		Cursor: order.Field.toCursor(ac),
	}
}

// BillingControlEdge is the edge representation of BillingControl.
type BillingControlEdge struct {
	Node   *BillingControl `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// BillingControlConnection is the connection containing edges to BillingControl.
type BillingControlConnection struct {
	Edges      []*BillingControlEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *BillingControlConnection) build(nodes []*BillingControl, pager *billingcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BillingControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BillingControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BillingControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*BillingControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BillingControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BillingControlPaginateOption enables pagination customization.
type BillingControlPaginateOption func(*billingcontrolPager) error

// WithBillingControlOrder configures pagination ordering.
func WithBillingControlOrder(order *BillingControlOrder) BillingControlPaginateOption {
	if order == nil {
		order = DefaultBillingControlOrder
	}
	o := *order
	return func(pager *billingcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBillingControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBillingControlFilter configures pagination filter.
func WithBillingControlFilter(filter func(*BillingControlQuery) (*BillingControlQuery, error)) BillingControlPaginateOption {
	return func(pager *billingcontrolPager) error {
		if filter == nil {
			return errors.New("BillingControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type billingcontrolPager struct {
	reverse bool
	order   *BillingControlOrder
	filter  func(*BillingControlQuery) (*BillingControlQuery, error)
}

func newBillingControlPager(opts []BillingControlPaginateOption, reverse bool) (*billingcontrolPager, error) {
	pager := &billingcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBillingControlOrder
	}
	return pager, nil
}

func (p *billingcontrolPager) applyFilter(query *BillingControlQuery) (*BillingControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *billingcontrolPager) toCursor(bc *BillingControl) Cursor {
	return p.order.Field.toCursor(bc)
}

func (p *billingcontrolPager) applyCursors(query *BillingControlQuery, after, before *Cursor) (*BillingControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBillingControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *billingcontrolPager) applyOrder(query *BillingControlQuery) *BillingControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBillingControlOrder.Field {
		query = query.Order(DefaultBillingControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *billingcontrolPager) orderExpr(query *BillingControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBillingControlOrder.Field {
			b.Comma().Ident(DefaultBillingControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BillingControl.
func (bc *BillingControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BillingControlPaginateOption,
) (*BillingControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBillingControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bc, err = pager.applyFilter(bc); err != nil {
		return nil, err
	}
	conn := &BillingControlConnection{Edges: []*BillingControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bc, err = pager.applyCursors(bc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bc = pager.applyOrder(bc)
	nodes, err := bc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BillingControlOrderField defines the ordering field of BillingControl.
type BillingControlOrderField struct {
	// Value extracts the ordering value from the given BillingControl.
	Value    func(*BillingControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) billingcontrol.OrderOption
	toCursor func(*BillingControl) Cursor
}

// BillingControlOrder defines the ordering of BillingControl.
type BillingControlOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *BillingControlOrderField `json:"field"`
}

// DefaultBillingControlOrder is the default ordering of BillingControl.
var DefaultBillingControlOrder = &BillingControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BillingControlOrderField{
		Value: func(bc *BillingControl) (ent.Value, error) {
			return bc.ID, nil
		},
		column: billingcontrol.FieldID,
		toTerm: billingcontrol.ByID,
		toCursor: func(bc *BillingControl) Cursor {
			return Cursor{ID: bc.ID}
		},
	},
}

// ToEdge converts BillingControl into BillingControlEdge.
func (bc *BillingControl) ToEdge(order *BillingControlOrder) *BillingControlEdge {
	if order == nil {
		order = DefaultBillingControlOrder
	}
	return &BillingControlEdge{
		Node:   bc,
		Cursor: order.Field.toCursor(bc),
	}
}

// BusinessUnitEdge is the edge representation of BusinessUnit.
type BusinessUnitEdge struct {
	Node   *BusinessUnit `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// BusinessUnitConnection is the connection containing edges to BusinessUnit.
type BusinessUnitConnection struct {
	Edges      []*BusinessUnitEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *BusinessUnitConnection) build(nodes []*BusinessUnit, pager *businessunitPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BusinessUnit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BusinessUnit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BusinessUnit {
			return nodes[i]
		}
	}
	c.Edges = make([]*BusinessUnitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BusinessUnitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BusinessUnitPaginateOption enables pagination customization.
type BusinessUnitPaginateOption func(*businessunitPager) error

// WithBusinessUnitOrder configures pagination ordering.
func WithBusinessUnitOrder(order *BusinessUnitOrder) BusinessUnitPaginateOption {
	if order == nil {
		order = DefaultBusinessUnitOrder
	}
	o := *order
	return func(pager *businessunitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBusinessUnitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBusinessUnitFilter configures pagination filter.
func WithBusinessUnitFilter(filter func(*BusinessUnitQuery) (*BusinessUnitQuery, error)) BusinessUnitPaginateOption {
	return func(pager *businessunitPager) error {
		if filter == nil {
			return errors.New("BusinessUnitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type businessunitPager struct {
	reverse bool
	order   *BusinessUnitOrder
	filter  func(*BusinessUnitQuery) (*BusinessUnitQuery, error)
}

func newBusinessUnitPager(opts []BusinessUnitPaginateOption, reverse bool) (*businessunitPager, error) {
	pager := &businessunitPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBusinessUnitOrder
	}
	return pager, nil
}

func (p *businessunitPager) applyFilter(query *BusinessUnitQuery) (*BusinessUnitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *businessunitPager) toCursor(bu *BusinessUnit) Cursor {
	return p.order.Field.toCursor(bu)
}

func (p *businessunitPager) applyCursors(query *BusinessUnitQuery, after, before *Cursor) (*BusinessUnitQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBusinessUnitOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *businessunitPager) applyOrder(query *BusinessUnitQuery) *BusinessUnitQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBusinessUnitOrder.Field {
		query = query.Order(DefaultBusinessUnitOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *businessunitPager) orderExpr(query *BusinessUnitQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBusinessUnitOrder.Field {
			b.Comma().Ident(DefaultBusinessUnitOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BusinessUnit.
func (bu *BusinessUnitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BusinessUnitPaginateOption,
) (*BusinessUnitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBusinessUnitPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bu, err = pager.applyFilter(bu); err != nil {
		return nil, err
	}
	conn := &BusinessUnitConnection{Edges: []*BusinessUnitEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bu.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bu, err = pager.applyCursors(bu, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bu = pager.applyOrder(bu)
	nodes, err := bu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BusinessUnitOrderField defines the ordering field of BusinessUnit.
type BusinessUnitOrderField struct {
	// Value extracts the ordering value from the given BusinessUnit.
	Value    func(*BusinessUnit) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) businessunit.OrderOption
	toCursor func(*BusinessUnit) Cursor
}

// BusinessUnitOrder defines the ordering of BusinessUnit.
type BusinessUnitOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *BusinessUnitOrderField `json:"field"`
}

// DefaultBusinessUnitOrder is the default ordering of BusinessUnit.
var DefaultBusinessUnitOrder = &BusinessUnitOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BusinessUnitOrderField{
		Value: func(bu *BusinessUnit) (ent.Value, error) {
			return bu.ID, nil
		},
		column: businessunit.FieldID,
		toTerm: businessunit.ByID,
		toCursor: func(bu *BusinessUnit) Cursor {
			return Cursor{ID: bu.ID}
		},
	},
}

// ToEdge converts BusinessUnit into BusinessUnitEdge.
func (bu *BusinessUnit) ToEdge(order *BusinessUnitOrder) *BusinessUnitEdge {
	if order == nil {
		order = DefaultBusinessUnitOrder
	}
	return &BusinessUnitEdge{
		Node:   bu,
		Cursor: order.Field.toCursor(bu),
	}
}

// CommodityEdge is the edge representation of Commodity.
type CommodityEdge struct {
	Node   *Commodity `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// CommodityConnection is the connection containing edges to Commodity.
type CommodityConnection struct {
	Edges      []*CommodityEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *CommodityConnection) build(nodes []*Commodity, pager *commodityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Commodity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Commodity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Commodity {
			return nodes[i]
		}
	}
	c.Edges = make([]*CommodityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CommodityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CommodityPaginateOption enables pagination customization.
type CommodityPaginateOption func(*commodityPager) error

// WithCommodityOrder configures pagination ordering.
func WithCommodityOrder(order *CommodityOrder) CommodityPaginateOption {
	if order == nil {
		order = DefaultCommodityOrder
	}
	o := *order
	return func(pager *commodityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommodityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommodityFilter configures pagination filter.
func WithCommodityFilter(filter func(*CommodityQuery) (*CommodityQuery, error)) CommodityPaginateOption {
	return func(pager *commodityPager) error {
		if filter == nil {
			return errors.New("CommodityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commodityPager struct {
	reverse bool
	order   *CommodityOrder
	filter  func(*CommodityQuery) (*CommodityQuery, error)
}

func newCommodityPager(opts []CommodityPaginateOption, reverse bool) (*commodityPager, error) {
	pager := &commodityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommodityOrder
	}
	return pager, nil
}

func (p *commodityPager) applyFilter(query *CommodityQuery) (*CommodityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commodityPager) toCursor(c *Commodity) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *commodityPager) applyCursors(query *CommodityQuery, after, before *Cursor) (*CommodityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCommodityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *commodityPager) applyOrder(query *CommodityQuery) *CommodityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCommodityOrder.Field {
		query = query.Order(DefaultCommodityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *commodityPager) orderExpr(query *CommodityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCommodityOrder.Field {
			b.Comma().Ident(DefaultCommodityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Commodity.
func (c *CommodityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommodityPaginateOption,
) (*CommodityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommodityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CommodityConnection{Edges: []*CommodityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CommodityOrderField defines the ordering field of Commodity.
type CommodityOrderField struct {
	// Value extracts the ordering value from the given Commodity.
	Value    func(*Commodity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) commodity.OrderOption
	toCursor func(*Commodity) Cursor
}

// CommodityOrder defines the ordering of Commodity.
type CommodityOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *CommodityOrderField `json:"field"`
}

// DefaultCommodityOrder is the default ordering of Commodity.
var DefaultCommodityOrder = &CommodityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CommodityOrderField{
		Value: func(c *Commodity) (ent.Value, error) {
			return c.ID, nil
		},
		column: commodity.FieldID,
		toTerm: commodity.ByID,
		toCursor: func(c *Commodity) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Commodity into CommodityEdge.
func (c *Commodity) ToEdge(order *CommodityOrder) *CommodityEdge {
	if order == nil {
		order = DefaultCommodityOrder
	}
	return &CommodityEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DispatchControlEdge is the edge representation of DispatchControl.
type DispatchControlEdge struct {
	Node   *DispatchControl `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// DispatchControlConnection is the connection containing edges to DispatchControl.
type DispatchControlConnection struct {
	Edges      []*DispatchControlEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *DispatchControlConnection) build(nodes []*DispatchControl, pager *dispatchcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DispatchControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DispatchControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DispatchControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*DispatchControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DispatchControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DispatchControlPaginateOption enables pagination customization.
type DispatchControlPaginateOption func(*dispatchcontrolPager) error

// WithDispatchControlOrder configures pagination ordering.
func WithDispatchControlOrder(order *DispatchControlOrder) DispatchControlPaginateOption {
	if order == nil {
		order = DefaultDispatchControlOrder
	}
	o := *order
	return func(pager *dispatchcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDispatchControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDispatchControlFilter configures pagination filter.
func WithDispatchControlFilter(filter func(*DispatchControlQuery) (*DispatchControlQuery, error)) DispatchControlPaginateOption {
	return func(pager *dispatchcontrolPager) error {
		if filter == nil {
			return errors.New("DispatchControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dispatchcontrolPager struct {
	reverse bool
	order   *DispatchControlOrder
	filter  func(*DispatchControlQuery) (*DispatchControlQuery, error)
}

func newDispatchControlPager(opts []DispatchControlPaginateOption, reverse bool) (*dispatchcontrolPager, error) {
	pager := &dispatchcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDispatchControlOrder
	}
	return pager, nil
}

func (p *dispatchcontrolPager) applyFilter(query *DispatchControlQuery) (*DispatchControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dispatchcontrolPager) toCursor(dc *DispatchControl) Cursor {
	return p.order.Field.toCursor(dc)
}

func (p *dispatchcontrolPager) applyCursors(query *DispatchControlQuery, after, before *Cursor) (*DispatchControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDispatchControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dispatchcontrolPager) applyOrder(query *DispatchControlQuery) *DispatchControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDispatchControlOrder.Field {
		query = query.Order(DefaultDispatchControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dispatchcontrolPager) orderExpr(query *DispatchControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDispatchControlOrder.Field {
			b.Comma().Ident(DefaultDispatchControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DispatchControl.
func (dc *DispatchControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DispatchControlPaginateOption,
) (*DispatchControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDispatchControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dc, err = pager.applyFilter(dc); err != nil {
		return nil, err
	}
	conn := &DispatchControlConnection{Edges: []*DispatchControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = dc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dc, err = pager.applyCursors(dc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		dc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dc = pager.applyOrder(dc)
	nodes, err := dc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DispatchControlOrderField defines the ordering field of DispatchControl.
type DispatchControlOrderField struct {
	// Value extracts the ordering value from the given DispatchControl.
	Value    func(*DispatchControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dispatchcontrol.OrderOption
	toCursor func(*DispatchControl) Cursor
}

// DispatchControlOrder defines the ordering of DispatchControl.
type DispatchControlOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *DispatchControlOrderField `json:"field"`
}

// DefaultDispatchControlOrder is the default ordering of DispatchControl.
var DefaultDispatchControlOrder = &DispatchControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DispatchControlOrderField{
		Value: func(dc *DispatchControl) (ent.Value, error) {
			return dc.ID, nil
		},
		column: dispatchcontrol.FieldID,
		toTerm: dispatchcontrol.ByID,
		toCursor: func(dc *DispatchControl) Cursor {
			return Cursor{ID: dc.ID}
		},
	},
}

// ToEdge converts DispatchControl into DispatchControlEdge.
func (dc *DispatchControl) ToEdge(order *DispatchControlOrder) *DispatchControlEdge {
	if order == nil {
		order = DefaultDispatchControlOrder
	}
	return &DispatchControlEdge{
		Node:   dc,
		Cursor: order.Field.toCursor(dc),
	}
}

// FeasibilityToolControlEdge is the edge representation of FeasibilityToolControl.
type FeasibilityToolControlEdge struct {
	Node   *FeasibilityToolControl `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// FeasibilityToolControlConnection is the connection containing edges to FeasibilityToolControl.
type FeasibilityToolControlConnection struct {
	Edges      []*FeasibilityToolControlEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *FeasibilityToolControlConnection) build(nodes []*FeasibilityToolControl, pager *feasibilitytoolcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FeasibilityToolControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FeasibilityToolControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FeasibilityToolControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*FeasibilityToolControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FeasibilityToolControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FeasibilityToolControlPaginateOption enables pagination customization.
type FeasibilityToolControlPaginateOption func(*feasibilitytoolcontrolPager) error

// WithFeasibilityToolControlOrder configures pagination ordering.
func WithFeasibilityToolControlOrder(order *FeasibilityToolControlOrder) FeasibilityToolControlPaginateOption {
	if order == nil {
		order = DefaultFeasibilityToolControlOrder
	}
	o := *order
	return func(pager *feasibilitytoolcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFeasibilityToolControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFeasibilityToolControlFilter configures pagination filter.
func WithFeasibilityToolControlFilter(filter func(*FeasibilityToolControlQuery) (*FeasibilityToolControlQuery, error)) FeasibilityToolControlPaginateOption {
	return func(pager *feasibilitytoolcontrolPager) error {
		if filter == nil {
			return errors.New("FeasibilityToolControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type feasibilitytoolcontrolPager struct {
	reverse bool
	order   *FeasibilityToolControlOrder
	filter  func(*FeasibilityToolControlQuery) (*FeasibilityToolControlQuery, error)
}

func newFeasibilityToolControlPager(opts []FeasibilityToolControlPaginateOption, reverse bool) (*feasibilitytoolcontrolPager, error) {
	pager := &feasibilitytoolcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFeasibilityToolControlOrder
	}
	return pager, nil
}

func (p *feasibilitytoolcontrolPager) applyFilter(query *FeasibilityToolControlQuery) (*FeasibilityToolControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *feasibilitytoolcontrolPager) toCursor(ftc *FeasibilityToolControl) Cursor {
	return p.order.Field.toCursor(ftc)
}

func (p *feasibilitytoolcontrolPager) applyCursors(query *FeasibilityToolControlQuery, after, before *Cursor) (*FeasibilityToolControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFeasibilityToolControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *feasibilitytoolcontrolPager) applyOrder(query *FeasibilityToolControlQuery) *FeasibilityToolControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFeasibilityToolControlOrder.Field {
		query = query.Order(DefaultFeasibilityToolControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *feasibilitytoolcontrolPager) orderExpr(query *FeasibilityToolControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFeasibilityToolControlOrder.Field {
			b.Comma().Ident(DefaultFeasibilityToolControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FeasibilityToolControl.
func (ftc *FeasibilityToolControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FeasibilityToolControlPaginateOption,
) (*FeasibilityToolControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFeasibilityToolControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ftc, err = pager.applyFilter(ftc); err != nil {
		return nil, err
	}
	conn := &FeasibilityToolControlConnection{Edges: []*FeasibilityToolControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ftc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ftc, err = pager.applyCursors(ftc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ftc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ftc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ftc = pager.applyOrder(ftc)
	nodes, err := ftc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FeasibilityToolControlOrderField defines the ordering field of FeasibilityToolControl.
type FeasibilityToolControlOrderField struct {
	// Value extracts the ordering value from the given FeasibilityToolControl.
	Value    func(*FeasibilityToolControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) feasibilitytoolcontrol.OrderOption
	toCursor func(*FeasibilityToolControl) Cursor
}

// FeasibilityToolControlOrder defines the ordering of FeasibilityToolControl.
type FeasibilityToolControlOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *FeasibilityToolControlOrderField `json:"field"`
}

// DefaultFeasibilityToolControlOrder is the default ordering of FeasibilityToolControl.
var DefaultFeasibilityToolControlOrder = &FeasibilityToolControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FeasibilityToolControlOrderField{
		Value: func(ftc *FeasibilityToolControl) (ent.Value, error) {
			return ftc.ID, nil
		},
		column: feasibilitytoolcontrol.FieldID,
		toTerm: feasibilitytoolcontrol.ByID,
		toCursor: func(ftc *FeasibilityToolControl) Cursor {
			return Cursor{ID: ftc.ID}
		},
	},
}

// ToEdge converts FeasibilityToolControl into FeasibilityToolControlEdge.
func (ftc *FeasibilityToolControl) ToEdge(order *FeasibilityToolControlOrder) *FeasibilityToolControlEdge {
	if order == nil {
		order = DefaultFeasibilityToolControlOrder
	}
	return &FeasibilityToolControlEdge{
		Node:   ftc,
		Cursor: order.Field.toCursor(ftc),
	}
}

// GeneralLedgerAccountEdge is the edge representation of GeneralLedgerAccount.
type GeneralLedgerAccountEdge struct {
	Node   *GeneralLedgerAccount `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// GeneralLedgerAccountConnection is the connection containing edges to GeneralLedgerAccount.
type GeneralLedgerAccountConnection struct {
	Edges      []*GeneralLedgerAccountEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *GeneralLedgerAccountConnection) build(nodes []*GeneralLedgerAccount, pager *generalledgeraccountPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GeneralLedgerAccount
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GeneralLedgerAccount {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GeneralLedgerAccount {
			return nodes[i]
		}
	}
	c.Edges = make([]*GeneralLedgerAccountEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GeneralLedgerAccountEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GeneralLedgerAccountPaginateOption enables pagination customization.
type GeneralLedgerAccountPaginateOption func(*generalledgeraccountPager) error

// WithGeneralLedgerAccountOrder configures pagination ordering.
func WithGeneralLedgerAccountOrder(order *GeneralLedgerAccountOrder) GeneralLedgerAccountPaginateOption {
	if order == nil {
		order = DefaultGeneralLedgerAccountOrder
	}
	o := *order
	return func(pager *generalledgeraccountPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGeneralLedgerAccountOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGeneralLedgerAccountFilter configures pagination filter.
func WithGeneralLedgerAccountFilter(filter func(*GeneralLedgerAccountQuery) (*GeneralLedgerAccountQuery, error)) GeneralLedgerAccountPaginateOption {
	return func(pager *generalledgeraccountPager) error {
		if filter == nil {
			return errors.New("GeneralLedgerAccountQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type generalledgeraccountPager struct {
	reverse bool
	order   *GeneralLedgerAccountOrder
	filter  func(*GeneralLedgerAccountQuery) (*GeneralLedgerAccountQuery, error)
}

func newGeneralLedgerAccountPager(opts []GeneralLedgerAccountPaginateOption, reverse bool) (*generalledgeraccountPager, error) {
	pager := &generalledgeraccountPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGeneralLedgerAccountOrder
	}
	return pager, nil
}

func (p *generalledgeraccountPager) applyFilter(query *GeneralLedgerAccountQuery) (*GeneralLedgerAccountQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *generalledgeraccountPager) toCursor(gla *GeneralLedgerAccount) Cursor {
	return p.order.Field.toCursor(gla)
}

func (p *generalledgeraccountPager) applyCursors(query *GeneralLedgerAccountQuery, after, before *Cursor) (*GeneralLedgerAccountQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGeneralLedgerAccountOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *generalledgeraccountPager) applyOrder(query *GeneralLedgerAccountQuery) *GeneralLedgerAccountQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGeneralLedgerAccountOrder.Field {
		query = query.Order(DefaultGeneralLedgerAccountOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *generalledgeraccountPager) orderExpr(query *GeneralLedgerAccountQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGeneralLedgerAccountOrder.Field {
			b.Comma().Ident(DefaultGeneralLedgerAccountOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GeneralLedgerAccount.
func (gla *GeneralLedgerAccountQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GeneralLedgerAccountPaginateOption,
) (*GeneralLedgerAccountConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGeneralLedgerAccountPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gla, err = pager.applyFilter(gla); err != nil {
		return nil, err
	}
	conn := &GeneralLedgerAccountConnection{Edges: []*GeneralLedgerAccountEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = gla.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gla, err = pager.applyCursors(gla, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		gla.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gla.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gla = pager.applyOrder(gla)
	nodes, err := gla.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GeneralLedgerAccountOrderField defines the ordering field of GeneralLedgerAccount.
type GeneralLedgerAccountOrderField struct {
	// Value extracts the ordering value from the given GeneralLedgerAccount.
	Value    func(*GeneralLedgerAccount) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) generalledgeraccount.OrderOption
	toCursor func(*GeneralLedgerAccount) Cursor
}

// GeneralLedgerAccountOrder defines the ordering of GeneralLedgerAccount.
type GeneralLedgerAccountOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *GeneralLedgerAccountOrderField `json:"field"`
}

// DefaultGeneralLedgerAccountOrder is the default ordering of GeneralLedgerAccount.
var DefaultGeneralLedgerAccountOrder = &GeneralLedgerAccountOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GeneralLedgerAccountOrderField{
		Value: func(gla *GeneralLedgerAccount) (ent.Value, error) {
			return gla.ID, nil
		},
		column: generalledgeraccount.FieldID,
		toTerm: generalledgeraccount.ByID,
		toCursor: func(gla *GeneralLedgerAccount) Cursor {
			return Cursor{ID: gla.ID}
		},
	},
}

// ToEdge converts GeneralLedgerAccount into GeneralLedgerAccountEdge.
func (gla *GeneralLedgerAccount) ToEdge(order *GeneralLedgerAccountOrder) *GeneralLedgerAccountEdge {
	if order == nil {
		order = DefaultGeneralLedgerAccountOrder
	}
	return &GeneralLedgerAccountEdge{
		Node:   gla,
		Cursor: order.Field.toCursor(gla),
	}
}

// HazardousMaterialEdge is the edge representation of HazardousMaterial.
type HazardousMaterialEdge struct {
	Node   *HazardousMaterial `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// HazardousMaterialConnection is the connection containing edges to HazardousMaterial.
type HazardousMaterialConnection struct {
	Edges      []*HazardousMaterialEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *HazardousMaterialConnection) build(nodes []*HazardousMaterial, pager *hazardousmaterialPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HazardousMaterial
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HazardousMaterial {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HazardousMaterial {
			return nodes[i]
		}
	}
	c.Edges = make([]*HazardousMaterialEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HazardousMaterialEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HazardousMaterialPaginateOption enables pagination customization.
type HazardousMaterialPaginateOption func(*hazardousmaterialPager) error

// WithHazardousMaterialOrder configures pagination ordering.
func WithHazardousMaterialOrder(order *HazardousMaterialOrder) HazardousMaterialPaginateOption {
	if order == nil {
		order = DefaultHazardousMaterialOrder
	}
	o := *order
	return func(pager *hazardousmaterialPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHazardousMaterialOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHazardousMaterialFilter configures pagination filter.
func WithHazardousMaterialFilter(filter func(*HazardousMaterialQuery) (*HazardousMaterialQuery, error)) HazardousMaterialPaginateOption {
	return func(pager *hazardousmaterialPager) error {
		if filter == nil {
			return errors.New("HazardousMaterialQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hazardousmaterialPager struct {
	reverse bool
	order   *HazardousMaterialOrder
	filter  func(*HazardousMaterialQuery) (*HazardousMaterialQuery, error)
}

func newHazardousMaterialPager(opts []HazardousMaterialPaginateOption, reverse bool) (*hazardousmaterialPager, error) {
	pager := &hazardousmaterialPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHazardousMaterialOrder
	}
	return pager, nil
}

func (p *hazardousmaterialPager) applyFilter(query *HazardousMaterialQuery) (*HazardousMaterialQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hazardousmaterialPager) toCursor(hm *HazardousMaterial) Cursor {
	return p.order.Field.toCursor(hm)
}

func (p *hazardousmaterialPager) applyCursors(query *HazardousMaterialQuery, after, before *Cursor) (*HazardousMaterialQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHazardousMaterialOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hazardousmaterialPager) applyOrder(query *HazardousMaterialQuery) *HazardousMaterialQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHazardousMaterialOrder.Field {
		query = query.Order(DefaultHazardousMaterialOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hazardousmaterialPager) orderExpr(query *HazardousMaterialQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHazardousMaterialOrder.Field {
			b.Comma().Ident(DefaultHazardousMaterialOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HazardousMaterial.
func (hm *HazardousMaterialQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HazardousMaterialPaginateOption,
) (*HazardousMaterialConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHazardousMaterialPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hm, err = pager.applyFilter(hm); err != nil {
		return nil, err
	}
	conn := &HazardousMaterialConnection{Edges: []*HazardousMaterialEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hm, err = pager.applyCursors(hm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		hm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hm = pager.applyOrder(hm)
	nodes, err := hm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HazardousMaterialOrderField defines the ordering field of HazardousMaterial.
type HazardousMaterialOrderField struct {
	// Value extracts the ordering value from the given HazardousMaterial.
	Value    func(*HazardousMaterial) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hazardousmaterial.OrderOption
	toCursor func(*HazardousMaterial) Cursor
}

// HazardousMaterialOrder defines the ordering of HazardousMaterial.
type HazardousMaterialOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *HazardousMaterialOrderField `json:"field"`
}

// DefaultHazardousMaterialOrder is the default ordering of HazardousMaterial.
var DefaultHazardousMaterialOrder = &HazardousMaterialOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HazardousMaterialOrderField{
		Value: func(hm *HazardousMaterial) (ent.Value, error) {
			return hm.ID, nil
		},
		column: hazardousmaterial.FieldID,
		toTerm: hazardousmaterial.ByID,
		toCursor: func(hm *HazardousMaterial) Cursor {
			return Cursor{ID: hm.ID}
		},
	},
}

// ToEdge converts HazardousMaterial into HazardousMaterialEdge.
func (hm *HazardousMaterial) ToEdge(order *HazardousMaterialOrder) *HazardousMaterialEdge {
	if order == nil {
		order = DefaultHazardousMaterialOrder
	}
	return &HazardousMaterialEdge{
		Node:   hm,
		Cursor: order.Field.toCursor(hm),
	}
}

// InvoiceControlEdge is the edge representation of InvoiceControl.
type InvoiceControlEdge struct {
	Node   *InvoiceControl `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// InvoiceControlConnection is the connection containing edges to InvoiceControl.
type InvoiceControlConnection struct {
	Edges      []*InvoiceControlEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *InvoiceControlConnection) build(nodes []*InvoiceControl, pager *invoicecontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InvoiceControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InvoiceControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InvoiceControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*InvoiceControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InvoiceControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InvoiceControlPaginateOption enables pagination customization.
type InvoiceControlPaginateOption func(*invoicecontrolPager) error

// WithInvoiceControlOrder configures pagination ordering.
func WithInvoiceControlOrder(order *InvoiceControlOrder) InvoiceControlPaginateOption {
	if order == nil {
		order = DefaultInvoiceControlOrder
	}
	o := *order
	return func(pager *invoicecontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInvoiceControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInvoiceControlFilter configures pagination filter.
func WithInvoiceControlFilter(filter func(*InvoiceControlQuery) (*InvoiceControlQuery, error)) InvoiceControlPaginateOption {
	return func(pager *invoicecontrolPager) error {
		if filter == nil {
			return errors.New("InvoiceControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type invoicecontrolPager struct {
	reverse bool
	order   *InvoiceControlOrder
	filter  func(*InvoiceControlQuery) (*InvoiceControlQuery, error)
}

func newInvoiceControlPager(opts []InvoiceControlPaginateOption, reverse bool) (*invoicecontrolPager, error) {
	pager := &invoicecontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInvoiceControlOrder
	}
	return pager, nil
}

func (p *invoicecontrolPager) applyFilter(query *InvoiceControlQuery) (*InvoiceControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *invoicecontrolPager) toCursor(ic *InvoiceControl) Cursor {
	return p.order.Field.toCursor(ic)
}

func (p *invoicecontrolPager) applyCursors(query *InvoiceControlQuery, after, before *Cursor) (*InvoiceControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInvoiceControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *invoicecontrolPager) applyOrder(query *InvoiceControlQuery) *InvoiceControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInvoiceControlOrder.Field {
		query = query.Order(DefaultInvoiceControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *invoicecontrolPager) orderExpr(query *InvoiceControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInvoiceControlOrder.Field {
			b.Comma().Ident(DefaultInvoiceControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InvoiceControl.
func (ic *InvoiceControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InvoiceControlPaginateOption,
) (*InvoiceControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInvoiceControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ic, err = pager.applyFilter(ic); err != nil {
		return nil, err
	}
	conn := &InvoiceControlConnection{Edges: []*InvoiceControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ic.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ic, err = pager.applyCursors(ic, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ic.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ic.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ic = pager.applyOrder(ic)
	nodes, err := ic.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InvoiceControlOrderField defines the ordering field of InvoiceControl.
type InvoiceControlOrderField struct {
	// Value extracts the ordering value from the given InvoiceControl.
	Value    func(*InvoiceControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) invoicecontrol.OrderOption
	toCursor func(*InvoiceControl) Cursor
}

// InvoiceControlOrder defines the ordering of InvoiceControl.
type InvoiceControlOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *InvoiceControlOrderField `json:"field"`
}

// DefaultInvoiceControlOrder is the default ordering of InvoiceControl.
var DefaultInvoiceControlOrder = &InvoiceControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InvoiceControlOrderField{
		Value: func(ic *InvoiceControl) (ent.Value, error) {
			return ic.ID, nil
		},
		column: invoicecontrol.FieldID,
		toTerm: invoicecontrol.ByID,
		toCursor: func(ic *InvoiceControl) Cursor {
			return Cursor{ID: ic.ID}
		},
	},
}

// ToEdge converts InvoiceControl into InvoiceControlEdge.
func (ic *InvoiceControl) ToEdge(order *InvoiceControlOrder) *InvoiceControlEdge {
	if order == nil {
		order = DefaultInvoiceControlOrder
	}
	return &InvoiceControlEdge{
		Node:   ic,
		Cursor: order.Field.toCursor(ic),
	}
}

// OrganizationEdge is the edge representation of Organization.
type OrganizationEdge struct {
	Node   *Organization `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrganizationConnection is the connection containing edges to Organization.
type OrganizationConnection struct {
	Edges      []*OrganizationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrganizationConnection) build(nodes []*Organization, pager *organizationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Organization
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Organization {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Organization {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrganizationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrganizationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrganizationPaginateOption enables pagination customization.
type OrganizationPaginateOption func(*organizationPager) error

// WithOrganizationOrder configures pagination ordering.
func WithOrganizationOrder(order *OrganizationOrder) OrganizationPaginateOption {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	o := *order
	return func(pager *organizationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrganizationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrganizationFilter configures pagination filter.
func WithOrganizationFilter(filter func(*OrganizationQuery) (*OrganizationQuery, error)) OrganizationPaginateOption {
	return func(pager *organizationPager) error {
		if filter == nil {
			return errors.New("OrganizationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type organizationPager struct {
	reverse bool
	order   *OrganizationOrder
	filter  func(*OrganizationQuery) (*OrganizationQuery, error)
}

func newOrganizationPager(opts []OrganizationPaginateOption, reverse bool) (*organizationPager, error) {
	pager := &organizationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrganizationOrder
	}
	return pager, nil
}

func (p *organizationPager) applyFilter(query *OrganizationQuery) (*OrganizationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *organizationPager) toCursor(o *Organization) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *organizationPager) applyCursors(query *OrganizationQuery, after, before *Cursor) (*OrganizationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrganizationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *organizationPager) applyOrder(query *OrganizationQuery) *OrganizationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrganizationOrder.Field {
		query = query.Order(DefaultOrganizationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *organizationPager) orderExpr(query *OrganizationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrganizationOrder.Field {
			b.Comma().Ident(DefaultOrganizationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Organization.
func (o *OrganizationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrganizationPaginateOption,
) (*OrganizationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrganizationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrganizationConnection{Edges: []*OrganizationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = o.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrganizationOrderField defines the ordering field of Organization.
type OrganizationOrderField struct {
	// Value extracts the ordering value from the given Organization.
	Value    func(*Organization) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) organization.OrderOption
	toCursor func(*Organization) Cursor
}

// OrganizationOrder defines the ordering of Organization.
type OrganizationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrganizationOrderField `json:"field"`
}

// DefaultOrganizationOrder is the default ordering of Organization.
var DefaultOrganizationOrder = &OrganizationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrganizationOrderField{
		Value: func(o *Organization) (ent.Value, error) {
			return o.ID, nil
		},
		column: organization.FieldID,
		toTerm: organization.ByID,
		toCursor: func(o *Organization) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Organization into OrganizationEdge.
func (o *Organization) ToEdge(order *OrganizationOrder) *OrganizationEdge {
	if order == nil {
		order = DefaultOrganizationOrder
	}
	return &OrganizationEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// RouteControlEdge is the edge representation of RouteControl.
type RouteControlEdge struct {
	Node   *RouteControl `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// RouteControlConnection is the connection containing edges to RouteControl.
type RouteControlConnection struct {
	Edges      []*RouteControlEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *RouteControlConnection) build(nodes []*RouteControl, pager *routecontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RouteControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RouteControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RouteControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*RouteControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RouteControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RouteControlPaginateOption enables pagination customization.
type RouteControlPaginateOption func(*routecontrolPager) error

// WithRouteControlOrder configures pagination ordering.
func WithRouteControlOrder(order *RouteControlOrder) RouteControlPaginateOption {
	if order == nil {
		order = DefaultRouteControlOrder
	}
	o := *order
	return func(pager *routecontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRouteControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRouteControlFilter configures pagination filter.
func WithRouteControlFilter(filter func(*RouteControlQuery) (*RouteControlQuery, error)) RouteControlPaginateOption {
	return func(pager *routecontrolPager) error {
		if filter == nil {
			return errors.New("RouteControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routecontrolPager struct {
	reverse bool
	order   *RouteControlOrder
	filter  func(*RouteControlQuery) (*RouteControlQuery, error)
}

func newRouteControlPager(opts []RouteControlPaginateOption, reverse bool) (*routecontrolPager, error) {
	pager := &routecontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRouteControlOrder
	}
	return pager, nil
}

func (p *routecontrolPager) applyFilter(query *RouteControlQuery) (*RouteControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routecontrolPager) toCursor(rc *RouteControl) Cursor {
	return p.order.Field.toCursor(rc)
}

func (p *routecontrolPager) applyCursors(query *RouteControlQuery, after, before *Cursor) (*RouteControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRouteControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *routecontrolPager) applyOrder(query *RouteControlQuery) *RouteControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRouteControlOrder.Field {
		query = query.Order(DefaultRouteControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *routecontrolPager) orderExpr(query *RouteControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRouteControlOrder.Field {
			b.Comma().Ident(DefaultRouteControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RouteControl.
func (rc *RouteControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RouteControlPaginateOption,
) (*RouteControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRouteControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rc, err = pager.applyFilter(rc); err != nil {
		return nil, err
	}
	conn := &RouteControlConnection{Edges: []*RouteControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rc, err = pager.applyCursors(rc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		rc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rc = pager.applyOrder(rc)
	nodes, err := rc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RouteControlOrderField defines the ordering field of RouteControl.
type RouteControlOrderField struct {
	// Value extracts the ordering value from the given RouteControl.
	Value    func(*RouteControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) routecontrol.OrderOption
	toCursor func(*RouteControl) Cursor
}

// RouteControlOrder defines the ordering of RouteControl.
type RouteControlOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *RouteControlOrderField `json:"field"`
}

// DefaultRouteControlOrder is the default ordering of RouteControl.
var DefaultRouteControlOrder = &RouteControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RouteControlOrderField{
		Value: func(rc *RouteControl) (ent.Value, error) {
			return rc.ID, nil
		},
		column: routecontrol.FieldID,
		toTerm: routecontrol.ByID,
		toCursor: func(rc *RouteControl) Cursor {
			return Cursor{ID: rc.ID}
		},
	},
}

// ToEdge converts RouteControl into RouteControlEdge.
func (rc *RouteControl) ToEdge(order *RouteControlOrder) *RouteControlEdge {
	if order == nil {
		order = DefaultRouteControlOrder
	}
	return &RouteControlEdge{
		Node:   rc,
		Cursor: order.Field.toCursor(rc),
	}
}

// ShipmentControlEdge is the edge representation of ShipmentControl.
type ShipmentControlEdge struct {
	Node   *ShipmentControl `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ShipmentControlConnection is the connection containing edges to ShipmentControl.
type ShipmentControlConnection struct {
	Edges      []*ShipmentControlEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ShipmentControlConnection) build(nodes []*ShipmentControl, pager *shipmentcontrolPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentControl
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentControl {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentControl {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentControlEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentControlEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentControlPaginateOption enables pagination customization.
type ShipmentControlPaginateOption func(*shipmentcontrolPager) error

// WithShipmentControlOrder configures pagination ordering.
func WithShipmentControlOrder(order *ShipmentControlOrder) ShipmentControlPaginateOption {
	if order == nil {
		order = DefaultShipmentControlOrder
	}
	o := *order
	return func(pager *shipmentcontrolPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentControlOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentControlFilter configures pagination filter.
func WithShipmentControlFilter(filter func(*ShipmentControlQuery) (*ShipmentControlQuery, error)) ShipmentControlPaginateOption {
	return func(pager *shipmentcontrolPager) error {
		if filter == nil {
			return errors.New("ShipmentControlQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentcontrolPager struct {
	reverse bool
	order   *ShipmentControlOrder
	filter  func(*ShipmentControlQuery) (*ShipmentControlQuery, error)
}

func newShipmentControlPager(opts []ShipmentControlPaginateOption, reverse bool) (*shipmentcontrolPager, error) {
	pager := &shipmentcontrolPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentControlOrder
	}
	return pager, nil
}

func (p *shipmentcontrolPager) applyFilter(query *ShipmentControlQuery) (*ShipmentControlQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentcontrolPager) toCursor(sc *ShipmentControl) Cursor {
	return p.order.Field.toCursor(sc)
}

func (p *shipmentcontrolPager) applyCursors(query *ShipmentControlQuery, after, before *Cursor) (*ShipmentControlQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentControlOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentcontrolPager) applyOrder(query *ShipmentControlQuery) *ShipmentControlQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentControlOrder.Field {
		query = query.Order(DefaultShipmentControlOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentcontrolPager) orderExpr(query *ShipmentControlQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentControlOrder.Field {
			b.Comma().Ident(DefaultShipmentControlOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentControl.
func (sc *ShipmentControlQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentControlPaginateOption,
) (*ShipmentControlConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentControlPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sc, err = pager.applyFilter(sc); err != nil {
		return nil, err
	}
	conn := &ShipmentControlConnection{Edges: []*ShipmentControlEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sc, err = pager.applyCursors(sc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sc = pager.applyOrder(sc)
	nodes, err := sc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentControlOrderField defines the ordering field of ShipmentControl.
type ShipmentControlOrderField struct {
	// Value extracts the ordering value from the given ShipmentControl.
	Value    func(*ShipmentControl) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentcontrol.OrderOption
	toCursor func(*ShipmentControl) Cursor
}

// ShipmentControlOrder defines the ordering of ShipmentControl.
type ShipmentControlOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ShipmentControlOrderField `json:"field"`
}

// DefaultShipmentControlOrder is the default ordering of ShipmentControl.
var DefaultShipmentControlOrder = &ShipmentControlOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentControlOrderField{
		Value: func(sc *ShipmentControl) (ent.Value, error) {
			return sc.ID, nil
		},
		column: shipmentcontrol.FieldID,
		toTerm: shipmentcontrol.ByID,
		toCursor: func(sc *ShipmentControl) Cursor {
			return Cursor{ID: sc.ID}
		},
	},
}

// ToEdge converts ShipmentControl into ShipmentControlEdge.
func (sc *ShipmentControl) ToEdge(order *ShipmentControlOrder) *ShipmentControlEdge {
	if order == nil {
		order = DefaultShipmentControlOrder
	}
	return &ShipmentControlEdge{
		Node:   sc,
		Cursor: order.Field.toCursor(sc),
	}
}

// TableChangeAlertEdge is the edge representation of TableChangeAlert.
type TableChangeAlertEdge struct {
	Node   *TableChangeAlert `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// TableChangeAlertConnection is the connection containing edges to TableChangeAlert.
type TableChangeAlertConnection struct {
	Edges      []*TableChangeAlertEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *TableChangeAlertConnection) build(nodes []*TableChangeAlert, pager *tablechangealertPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TableChangeAlert
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TableChangeAlert {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TableChangeAlert {
			return nodes[i]
		}
	}
	c.Edges = make([]*TableChangeAlertEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TableChangeAlertEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TableChangeAlertPaginateOption enables pagination customization.
type TableChangeAlertPaginateOption func(*tablechangealertPager) error

// WithTableChangeAlertOrder configures pagination ordering.
func WithTableChangeAlertOrder(order *TableChangeAlertOrder) TableChangeAlertPaginateOption {
	if order == nil {
		order = DefaultTableChangeAlertOrder
	}
	o := *order
	return func(pager *tablechangealertPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTableChangeAlertOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTableChangeAlertFilter configures pagination filter.
func WithTableChangeAlertFilter(filter func(*TableChangeAlertQuery) (*TableChangeAlertQuery, error)) TableChangeAlertPaginateOption {
	return func(pager *tablechangealertPager) error {
		if filter == nil {
			return errors.New("TableChangeAlertQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tablechangealertPager struct {
	reverse bool
	order   *TableChangeAlertOrder
	filter  func(*TableChangeAlertQuery) (*TableChangeAlertQuery, error)
}

func newTableChangeAlertPager(opts []TableChangeAlertPaginateOption, reverse bool) (*tablechangealertPager, error) {
	pager := &tablechangealertPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTableChangeAlertOrder
	}
	return pager, nil
}

func (p *tablechangealertPager) applyFilter(query *TableChangeAlertQuery) (*TableChangeAlertQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tablechangealertPager) toCursor(tca *TableChangeAlert) Cursor {
	return p.order.Field.toCursor(tca)
}

func (p *tablechangealertPager) applyCursors(query *TableChangeAlertQuery, after, before *Cursor) (*TableChangeAlertQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTableChangeAlertOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tablechangealertPager) applyOrder(query *TableChangeAlertQuery) *TableChangeAlertQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTableChangeAlertOrder.Field {
		query = query.Order(DefaultTableChangeAlertOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tablechangealertPager) orderExpr(query *TableChangeAlertQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTableChangeAlertOrder.Field {
			b.Comma().Ident(DefaultTableChangeAlertOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TableChangeAlert.
func (tca *TableChangeAlertQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TableChangeAlertPaginateOption,
) (*TableChangeAlertConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTableChangeAlertPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tca, err = pager.applyFilter(tca); err != nil {
		return nil, err
	}
	conn := &TableChangeAlertConnection{Edges: []*TableChangeAlertEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = tca.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tca, err = pager.applyCursors(tca, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		tca.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tca.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tca = pager.applyOrder(tca)
	nodes, err := tca.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TableChangeAlertOrderField defines the ordering field of TableChangeAlert.
type TableChangeAlertOrderField struct {
	// Value extracts the ordering value from the given TableChangeAlert.
	Value    func(*TableChangeAlert) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tablechangealert.OrderOption
	toCursor func(*TableChangeAlert) Cursor
}

// TableChangeAlertOrder defines the ordering of TableChangeAlert.
type TableChangeAlertOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *TableChangeAlertOrderField `json:"field"`
}

// DefaultTableChangeAlertOrder is the default ordering of TableChangeAlert.
var DefaultTableChangeAlertOrder = &TableChangeAlertOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TableChangeAlertOrderField{
		Value: func(tca *TableChangeAlert) (ent.Value, error) {
			return tca.ID, nil
		},
		column: tablechangealert.FieldID,
		toTerm: tablechangealert.ByID,
		toCursor: func(tca *TableChangeAlert) Cursor {
			return Cursor{ID: tca.ID}
		},
	},
}

// ToEdge converts TableChangeAlert into TableChangeAlertEdge.
func (tca *TableChangeAlert) ToEdge(order *TableChangeAlertOrder) *TableChangeAlertEdge {
	if order == nil {
		order = DefaultTableChangeAlertOrder
	}
	return &TableChangeAlertEdge{
		Node:   tca,
		Cursor: order.Field.toCursor(tca),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *TagConnection) build(nodes []*Tag, pager *tagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order *TagOrder) TagPaginateOption {
	if order == nil {
		order = DefaultTagOrder
	}
	o := *order
	return func(pager *tagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	reverse bool
	order   *TagOrder
	filter  func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption, reverse bool) (*tagPager, error) {
	pager := &tagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTagOrder
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) (*TagQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTagOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tagPager) applyOrder(query *TagQuery) *TagQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTagOrder.Field {
		query = query.Order(DefaultTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tagPager) orderExpr(query *TagQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTagOrder.Field {
			b.Comma().Ident(DefaultTagOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TagConnection{Edges: []*TagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	// Value extracts the ordering value from the given Tag.
	Value    func(*Tag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tag.OrderOption
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.ID, nil
		},
		column: tag.FieldID,
		toTerm: tag.ByID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
